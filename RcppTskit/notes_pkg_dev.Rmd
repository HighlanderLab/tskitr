# Notes on RcppTskit package development

## Next TODOs

## TableCollection indexes and `tree_sequence()` (notes for future work)

### Why this note exists

I got a bit hazy on how indexes are handled across tskit C, tskit Python,
and `RcppTskit` when converting a `TableCollection` to a `TreeSequence`.
This note Codex summarised the current understanding and suggests a future path.
We have to study this and decide how to move onwards.

### tskit Python API behavior (reference behavior for R API)

- `TableCollection.tree_sequence()` is user-facing and Pythonic (no bitwise flags).
- It checks `self.has_index()`.
- If indexes are missing, it calls `self.build_index()`.
- Then it calls `tskit.TreeSequence.load_tables(self)`.

In other words: Python handles index preparation explicitly at the
`TableCollection` layer before creating a `TreeSequence`.

Python also exposes these `TableCollection` methods:

- `has_index()`
- `build_index()`
- `drop_index()`

### tskit C API behavior (reference behavior for low-level C++ wrappers)

- `tsk_table_collection_has_index(...)`
- `tsk_table_collection_build_index(...)`
- `tsk_table_collection_drop_index(...)`
- `tsk_treeseq_init(..., options)` where `options` may include:
  - `TSK_TS_INIT_BUILD_INDEXES`
  - `TSK_TS_INIT_COMPUTE_MUTATION_PARENTS`

`TSK_TS_INIT_BUILD_INDEXES` is a C-level bitwise option and fits naturally in
the low-level `tc_ptr_to_ts_ptr(..., options)` wrapper.

### Current `RcppTskit` behavior (as of this note)

- Public R method `TableCollection$tree_sequence()` currently sets
  `TSK_TS_INIT_BUILD_INDEXES` (via `bitwShiftL(1L, 0)`) and passes it to
  `tc_ptr_to_ts_ptr(...)`.
- This is functionally fine, but it exposes C-style flag handling in the R
  method implementation.

Important nuance:

- `tc_ptr_to_ts_ptr()` calls `tsk_treeseq_init(...)` without `TSK_TAKE_OWNERSHIP`.
- In tskit C, this means the tree sequence gets its own copied tables.
- If `TSK_TS_INIT_BUILD_INDEXES` is used there, indexes are built on the copied
  tables (inside the tree sequence init path), not necessarily on the original
  R `TableCollection` object.

This differs from Python `TableCollection.tree_sequence()` behavior, which
builds indexes on the table collection itself before conversion.

### Consistency goal (recommended)

Use two layers with different styles on purpose:

- R public API: Python-like, simple methods / logical arguments
- C++ low-level wrappers: C-like, bitwise `options` allowed

That gives:

- R-Python consistency for user-facing behavior
- C-C++ consistency for thin wrappers

### Suggested future refactor for `TableCollection$tree_sequence()`

Refactor R method to follow Python semantics explicitly:

```r
tree_sequence = function() {
  if (!self$has_index()) {
    self$build_index()
  }
  ts_ptr <- tc_ptr_to_ts_ptr(self$pointer, options = 0L)
  TreeSequence$new(pointer = ts_ptr)
}
```

Benefits:

- No bitwise flag logic in R method implementation
- Easier to read and explain
- Matches Python behavior more closely
- Makes `has_index()` tests and state transitions clearer

### Why `skip_tables = TRUE` is not a good "no index" test case

I initially wondered whether loading a table collection with empty tables would
imply `has_index() == FALSE`. It does not reliably do that.

Observation from local Python check:

- `TableCollection.load(..., skip_tables=True)` can still report `has_index() == TRUE`
  even when `num_edges == 0`.

So:

- "no rows" does not necessarily mean "no index"
- `skip_tables=TRUE` is not a robust negative test for `has_index()`

### Best way to test `has_index()` false cases

Add explicit index mutators to R API (matching Python):

- `tc_ptr_build_index()` + `TableCollection$build_index()`
- `tc_ptr_drop_index()` + `TableCollection$drop_index()`

Then tests become simple and deterministic:

1. Load `tc`
2. `expect_true(tc$has_index())`
3. `tc$drop_index()`
4. `expect_false(tc$has_index())`
5. `tc$build_index()`
6. `expect_true(tc$has_index())`

And for `tree_sequence()` behavior:

1. Load `tc`
2. `tc$drop_index()`
3. `expect_false(tc$has_index())`
4. `ts <- tc$tree_sequence()`
5. Decide/document expected side effect:
   - Python-consistent target: `tc$has_index()` becomes `TRUE`
   - Current C-flag-inside-init approach may leave `tc` unchanged

### Design decision to make explicitly (before implementing)

Choose one and document it:

- **Python-consistent behavior (recommended)**:
  `TableCollection$tree_sequence()` may build indexes on `self` if missing.
- **Non-mutating conversion behavior**:
  `TableCollection$tree_sequence()` builds indexes only in the transient treeseq
  init path and leaves `self` as-is.

The first option is more consistent with tskit Python and easier to reason
about for users switching between R and Python.

### Minimal next steps when time allows

1. Add `TableCollection$build_index()` / `$drop_index()` (+ `tc_ptr_*` wrappers).
2. Add focused tests for `has_index()` false/true transitions.
3. Refactor `TableCollection$tree_sequence()` to Python-style pre-check and
   `build_index()`.
4. Add a regression test for `tc$tree_sequence()` behavior after dropping index.
5. Keep `tc_ptr_to_ts_ptr(..., options)` as low-level C-like API (do not remove).

### Optional later (separate concern)

If needed, consider a Python-style logical argument on the R method for
mutation-parent computation instead of exposing bitwise flags, e.g.
`compute_mutation_parents = FALSE`, while still translating to
`TSK_TS_INIT_COMPUTE_MUTATION_PARENTS` inside the low-level wrapper layer.

// TODO: This will go into AlphaSimR

Tskit examples of building tree sequence in C
extern/tskit/c/tests/testlib.c has lots of examples of constructing a tree sequence using C
extern/tskit/c/tests/test_minimal_cpp.cpp has some C++ example too
extern/tskit/c/examples/haploid_wright_fisher.c
extern/tskit/c/examples/multichrom_wright_fisher_singlethreaded.c
extern/tskit/c/examples/multichrom_wright_fisher.c

// [[Rcpp::export]]
SEXP tc_grow(SEXP tc) {
  RcppTskit_table_collection_xptr tc_xptr(tc);
  int ret;
  ret = 0;
  // Minimal example: grow the table collection in place by appending one child
  // node and one edge spanning the full sequence. A real simulator would choose
  // parent(s), times, and intervals according to its model.
  if (tc_xptr->nodes.num_rows == 0) {
    ret = TSK_ERR_NODE_OUT_OF_BOUNDS;
  } else {
    const tsk_id_t parent = tc_xptr->nodes.num_rows - 1;
    const tsk_id_t child = tsk_node_table_add_row(&tc_xptr->nodes, TSK_NODE_IS_SAMPLE,
                                                  0.0, TSK_NULL, TSK_NULL, NULL, 0);
    if (child < 0) {
      ret = static_cast<int>(child);
    } else {
      const tsk_id_t edge = tsk_edge_table_add_row(
          &tc_xptr->edges, 0.0, tc_xptr->sequence_length, parent, child, NULL, 0);
      if (edge < 0) {
        ret = static_cast<int>(edge);
      }
    }
  }
  if (ret == 0) {
    ret = tsk_table_collection_sort(tc_xptr, NULL, 0);
  }
  if (ret == 0) {
    ret = tsk_table_collection_build_index(tc_xptr, 0);
  }
  if (ret != 0) {
    // TODO: What should we do if something goes wrong? We can clearly throw an
    //       error using Rcpp::stop(), but should we also do something with the
    //       ts pointer and object? If we delete, we discard/delete past work,
    //       but if we do not, do we risk of returning a corrupted ts?
    // tsk_table_collection_free(tc_ptr);
    // delete tc_ptr;
    Rcpp::stop(tsk_strerror(ret));
  }
  return tc_xptr;
  // or do we want to return ts?
}

* This PR nicely shows how slendr is dealing with ts objects
  (it saves various ts information as attributes)
  https://github.com/bodkan/slendr/pull/191/changes#diff-f46eb0da2f9267022ecc6e09316598fde6bdcd2f980963906dc041b5096f344f


## NEWS template

```
## [Unreleased] - YYYY-MM-DD

Routinely log changes in the package ...

## [MAJOR.MINOR.PATCH] - YYYY-MM-DD

MAJOR version when you make incompatible API changes
MINOR version when you add functionality in a backward compatible manner
PATCH version when you make backward compatible bug fixes

### Added (new features)

- Describe 1 ...
- Describe 2 ...

### Changed (for changes in existing functionality)
### Deprecated (soon-to-be removed features)
### Removed (now removed features)
### Fixed (bug fixes)
### Security (vulnerabilities)
### Maintenance (non-user facing changes, e.g. refactoring, CI updates, etc.)
```

## Prepare for release

```
use_upkeep_issue(year = NULL) # https://usethis.r-lib.org/reference/use_upkeep_issue.html
use_release_issue(version = NULL) # https://usethis.r-lib.org/reference/use_release_issue.html
# just follow tasks in there;)
```

## Dev tools setup / use

```
install.packages(c("usethis", "devtools"))
```

### Code testing coverage with covr

https://covr.r-lib.org

```
install.packages("covr")

# https://usethis.r-lib.org/reference/use_coverage.html
usethis::use_coverage(type = "codecov")

# Build the report & report
cov <- covr::package_coverage(clean = TRUE); covr::report(cov)

# Build the report
cov <- covr::package_coverage(clean = TRUE)

# Interactive HTML report with uncovered lines highlighted
covr::report(cov)

# List lines with zero coverage per file
covr::zero_coverage(cov)

# Show coverage for a specific file
covr::report(cov, file = "R/RcppTskit-package.R")
covr::report(cov, file = "src/RcppTskit_minimal.cpp")

# If you want a quick text view of uncovered lines:
covr::file_coverage("R/RcppTskit-package.R", "tests/testthat")
covr::file_coverage("src/RcppTskit_minimal.cpp", "tests/testthat")
```

To ignore specific lines, use `# nocov`

To ignore multiple lines use `# nocov start/stop`.

In `Rcpp` code use `// # nocov ...`.

### Debugging C/C++

In `src/Makevars.in` uncomment debug flags ...

From terminal run:

```
# Go to package folder
R_HOME="/Library/Frameworks/R.framework/Resources"
R_BIN="$R_HOME/bin/exec/R"
ASAN="/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/17/lib/darwin/libclang_rt.asan_osx_dynamic.dylib"
UBSAN="/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/17/lib/darwin/libclang_rt.ubsan_osx_dynamic.dylib"

env R_HOME="$R_HOME" \
  DYLD_INSERT_LIBRARIES="$ASAN:$UBSAN" \
  ASAN_OPTIONS="abort_on_error=1,detect_leaks=0,verbosity=1" \
  UBSAN_OPTIONS="print_stacktrace=1" \
  "$R_BIN" --vanilla
```

In the R session (not from Rstudio/Positron!):

```
# Load + compile into the current ASan session (no child R load)
devtools::load_all()

# Run tests in the same process
devtools::test()
```

### Air formatter of R code

https://usethis.r-lib.org/reference/use_air.html
```
usethis::use_air()
```

https://posit-dev.github.io/air

Setup editor and `air.toml`.

In comand line, run:

```
air format .
air format --check .
```

### Jarl linter of R code

https://jarl.etiennebacher.com

Setup editor and `jarl.toml`. Can also do `~/.config/jarl`.

```
jarl check .
jarl check --fix .
```

### clang-format of C/C++ code

https://clang.llvm.org/docs/ClangFormat.html

```
# All files (run from the RcppTskit directory)
find src -type f \( -name '*.c' -o -name '*.cpp' -o -name '*.h' -o -name '*.hpp' \) \
  ! -path 'inst/include/tskit/*' \
  ! -path 'src/tskit/*' \
  ! -path 'src/RcppExports.cpp' \
  -exec clang-format -i {} +

# All files (run from the repo root)
find . -type f \( -name '*.c' -o -name '*.cpp' -o -name '*.h' -o -name '*.hpp' \) \
  ! -path './extern/*' \
  ! -path './RcppTskit/inst/include/tskit/*' \
  ! -path './RcppTskit/src/tskit/*' \
  ! -path './RcppTskit/src/RcppExports.cpp' \
  -exec clang-format -i {} +

# Single file
clang-format -i --style=file src/RcppTskit_minimal.cpp

# Only changes
git diff --name-only main | grep -E '\.(c|cpp|h|hpp)$' | xargs clang-format -i
```

or

```
pre-commit run clang-format src/RcppTskit.cpp
pre-commit run clang-format --all-files
```

### clang-tidy linter of C/C++ code

https://clang.llvm.org/extra/clang-tidy/

```
echo $(brew --prefix llvm)/bin/clang-tidy
# /opt/homebrew/opt/llvm/bin/clang-tidy
export CLANG_TIDY="$(brew --prefix llvm)/bin/clang-tidy"
./tools/clang-tidy.py src/RcppTskit.cpp
./RcppTskit/tools/clang-tidy.py RcppTskit/src/test_tsk_abort_stderr.cpp -- -system-headers '-header-filter=.*'   -extra-arg=-Wno-unknown-warning-option
./tools/clang-tidy.py src/test_tsk_abort_stderr.cpp -- -system-headers '-header-filter=.*'   -extra-arg=-Wno-unknown-warning-option
```

or

```
pre-commit run clang-tidy src/RcppTskit.cpp
pre-commit run clang-tidy --all-files
```

### GitHub actions

```
install.packages("usethis")

# R CMD check
usethis::use_github_action("check-standard")

# Code testing coverage with covr
usethis::use_github_action("test-coverage")

# Air formatting --> moved to pre-commit
usethis::use_github_action(url = "https://github.com/posit-dev/setup-air/blob/main/examples/format-suggest.yaml")
usethis::use_github_action(url = "https://github.com/posit-dev/setup-air/blob/main/examples/format-check.yaml")
```
