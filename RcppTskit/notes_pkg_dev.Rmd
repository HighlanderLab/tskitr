# Notes on RcppTskit package development

## Next TODOs

Below are notes on:

Providing zero-copy read access to the table columns and tree arrays? #49
https://github.com/HighlanderLab/RcppTskit/issues/49

------------------------------------------------------------------------------

Providing zero-copy read access to the table columns and tree arrays? #49
https://github.com/HighlanderLab/RcppTskit/issues/49

* For `ts_py.num_individuals` the path is:

`trees.py`
```
class TreeSequence:
    ...
    @property
    def num_individuals(self):
        """
        Returns the number of :ref:`individuals <sec_individual_table_definition>` in
        this tree sequence.

        :return: The number of individuals in this tree sequence.
        :rtype: int
        """
        return self._ll_tree_sequence.get_num_individuals()
    ...
```

`_tskitmodule.c`
```
static PyMethodDef TreeSequence_methods[] = {
    ...
    { .ml_name = "get_num_individuals",
        .ml_meth = (PyCFunction) TreeSequence_get_num_individuals,
        .ml_flags = METH_NOARGS,
        .ml_doc = "Returns the number of individual records." },
    ...

static PyObject *
TreeSequence_get_num_individuals(TreeSequence *self, PyObject *args)
{
    PyObject *ret = NULL;
    tsk_size_t num_records;

    if (TreeSequence_check_state(self) != 0) {
        goto out;
    }
    num_records = tsk_treeseq_get_num_individuals(self->tree_sequence);
    ret = Py_BuildValue("n", (Py_ssize_t) num_records);
out:
    return ret;
}
```

So, for each scalar there is a class property (in Python),
calling a C glue function between C and Python (in _tskitmodule.c),
this function (TreeSequence_get_num_individuals) extracts the value
(num_records = tsk_treeseq_get_num_individuals(self->tree_sequence);) and
returns it to Python.
Hence this single value is a copy.
We are doing something similar in RcppTskit.

* Python class property calls low-level C binding.
* C binding calls tskit C API getter.
* Result is returned as a new Python scalar object.
* So that scalar value is materialized (effectively copied) into Python.
* RcppTskit scalar getters are the same pattern semantically.
* Zero-copy is mainly relevant for array/column access, not scalar fields.

------------------------------------------------------------------------------

* For `ts_py.tables.nodes.time` path (zero-copy read or immutable table/column) is:

`trees.py`
```
class TreeSequence:
    ...
    @property
    def tables(self):
        """
        Returns an immutable view of the tables underlying this tree sequence.

        This view shares the same data as the TreeSequence (zero-copy).
        Use :meth:`.dump_tables` for a modifiable copy.

        Note that if tskit was built with Numpy 1, this method acts as
        :meth:`.dump_tables` and returns a mutable TableCollection.

        :return: An immutable view of the TableCollection underlying this tree sequence.
        """
        if not _tskit.HAS_NUMPY_2:
            warnings.warn(
                "Immutable table views require tskit to be built against NumPy 2.0 or "
                "newer. Falling back to returning a mutable TableCollection.",
                UserWarning,
                stacklevel=2,
            )
            return self.dump_tables()
        if self._immutable_tables is None:
            self._immutable_tables = tables.ImmutableTableCollection(
                self._ll_tree_sequence
            )
        return self._immutable_tables
```

`tables.py`
```
class ImmutableNodeTable(ImmutableMetadataTable):
    table_name = "nodes"
    mutable_class = NodeTable

    column_names = [
        "time",
        "flags",
        "population",
        "individual",
        "metadata",
        "metadata_offset",
    ]

class ImmutableBaseTable(BaseTable):
    ...
    def __getattr__(self, name):
        # Handle attribute access. This method is only called when an attribute
        # is not found through normal lookup, so we can lazily calculate column
        # contents.
        if name in self._set_column_names:
            full_array = getattr(self._llts, f"{self.table_name}_{name}")
            # TableCollection methods use the LWT code, which is stuck returning
            # int8 for compatibility see https://github.com/tskit-dev/tskit/issues/3284
            if name == "metadata":
                full_array = full_array.view(np.int8)
            if not (self._row_indices is None and self._row_slice is None):
                is_offset = name.endswith("_offset")
                is_ragged = f"{name}_offset" in self._set_column_names
                if self._row_indices is None:
                    subset_array = self._slice_column(
                        full_array, name, is_offset, is_ragged
                    )
                else:
                    subset_array = self._select_column(
                        full_array, name, is_offset, is_ragged
                    )
            else:
                subset_array = full_array
            # Store the result, so on the next access we don't need to calculate it again
            object.__setattr__(self, name, subset_array)
            return subset_array
```

`_tskitmodule.c`
```
static PyGetSetDef TreeSequence_getsetters[] = {
    ...
    { .name = "nodes_time",
        .get = (getter) TreeSequence_get_nodes_time,
        .doc = "The node time array" },
    ...

/* Universal macro for all array accessors */
#define DEFINE_ARRAY_ACCESSOR(                                                          \
    table_name, field_name, table_type, numpy_type, count_expr)                         \
    static PyObject *TreeSequence_get_##table_name##_##field_name(                      \
        TreeSequence *self, void *closure)                                              \
    {                                                                                   \
        PyObject *ret = NULL;                                                           \
        tsk_##table_type##_table_t table;                                               \
                                                                                        \
        if (TreeSequence_check_state(self) != 0) {                                      \
            goto out;                                                                   \
        }                                                                               \
        table = self->tree_sequence->tables->table_name;                                \
        ret = TreeSequence_make_array(self, count_expr, numpy_type, table.field_name);  \
    out:                                                                                \
        return ret;                                                                     \
    }

...
DEFINE_ARRAY_ACCESSOR(nodes, time, node, NPY_FLOAT64, table.num_rows)
...

/* Make a new array that is owned by the specified object. */
static PyObject *
make_owned_array(PyObject *self, tsk_size_t size, int dtype, void *data)
{
    PyObject *ret = NULL;
    PyArrayObject *array = NULL;
    npy_intp dims = (npy_intp) size;

    array = (PyArrayObject *) PyArray_SimpleNewFromData(1, &dims, dtype, data);
    if (array == NULL) {
        goto out;
    }
    PyArray_CLEARFLAGS(array, NPY_ARRAY_WRITEABLE);
    if (PyArray_SetBaseObject(array, (PyObject *) self) != 0) {
        goto out;
    }
    /* PyArray_SetBaseObject steals a reference, so we have to incref this
     * object. This makes sure that the instance will stay alive if there
     * are any arrays that refer to its memory. */
    Py_INCREF(self);
    ret = (PyObject *) array;
    array = NULL;
out:
    Py_XDECREF(array);
    return ret;
}
```

For vectors, we have TreeSequence class with tables property,
which is an ImmutableNodeTable, ..., ImmutableBaseTable has __getattr__,
then we call C TreeSequence_getsetters/TreeSequence_get_nodes_time, which calls
table = self->tree_sequence->tables->table_name;
ret = TreeSequence_make_array(self, count_expr, numpy_type, table.field_name);
and array is created for Python in make_owned_array and
this is zero-copy because ret is a Python ndarray object,
whose internal data pointer is set to table.field_name via PyArray_SimpleNewFromData(...),
hence no memcpy. make_owned_array makes it read-only and
sets the base object to the TreeSequence so the underlying C memory stays alive.
table = self->tree_sequence->tables->table_name; copies the small struct header,
but the column pointers inside still reference underlying TS memory.

------------------------------------------------------------------------------

* For `NodeTable.time` (mutable table/column, hence the copy) the path is:

`_tskitmodule.c`
```
#define DEFINE_TABLE_COLUMN_GETTER(table_class, column_name, numpy_type, c_type)        \
    static PyObject *table_class##Table_get_##column_name(                              \
        table_class##Table *self, void *closure)                                        \
    {                                                                                   \
        PyObject *ret = NULL;                                                           \
        if (table_class##Table_check_state(self) != 0) {                                \
            goto out;                                                                   \
        }                                                                               \
        ret = table_get_column_array(self->table->num_rows, self->table->column_name,   \
            numpy_type, sizeof(c_type));                                                \
    out:                                                                                \
        return ret;                                                                     \
    }


static PyObject *
table_get_column_array(
    tsk_size_t num_rows, void *data, int npy_type, size_t element_size)
{
    PyObject *ret = NULL;
    PyArrayObject *array;
    npy_intp dims = (npy_intp) num_rows;

    array = (PyArrayObject *) PyArray_EMPTY(1, &dims, npy_type, 0);
    if (array == NULL) {
        goto out;
    }
    memcpy(PyArray_DATA(array), data, num_rows * element_size);
    ret = (PyObject *) array;
out:
    return ret;
}
```

For mutable column, we call instead *table_class##Table_get_##column_name,
calling table_get_column_array,
which creates PyArray_EMPTY and memcpy data into it,
hence the copy.

------------------------------------------------------------------------------

Zero copy in R ideas based on ALTREP:

-------------------------------------------------------------------------------

A simpler? one than a more complex one below:

1) Put ts_ptr in data1 (owner/lifetime anchor).
2) Leave data2 as R_NilValue.
3) In each ALTREP method, read pointer/length directly from ts_ptr.

This looks ugly since it uses ALTREP methods (Length, Elt, Dataptr, Duplicate);
low-level C callbacks called directly by R internals.

Length: returns vector size (R_xlen_t).
Called for length(x), bounds checks, loops.

Elt: returns one element at index i. Called for element-wise access like x[i]
when R is not using a raw pointer path.

Dataptr: returns a contiguous memory pointer (void*) to the vector data.
Used when code asks for direct buffer access (like REAL(x) in C code).
If writeable = TRUE, you must either provide mutable memory or error.

Dataptr_or_null: same idea, but allowed to return NULL if no direct pointer is available.

Duplicate defines what happens when R duplicates an ALTREP object
(duplicate(), some copy-on-modify paths, internal cloning).

For zero-copy nodes.time ALTREP:
* Length = number of nodes,
* Elt = nodes.time[i],
* Dataptr_or_null = pointer to tskit nodes.time buffer if direct access is available;
  otherwise NULL (in our case, return the real pointer).
* Dataptr = pointer to tskit nodes.time buffer (read-only).
* Duplicate = allocate a regular R double vector and copy nodes.time into it
  (materialize a standalone R-owned copy).

#include <R_ext/Altrep.h>
#include <Rinternals.h>
#include <RcppTskit.hpp>
#include <cstring>

namespace {
R_altrep_class_t nodes_time_cls = nullptr;

inline tsk_treeseq_t *get_ts(SEXP x) {
  auto *ts = static_cast<tsk_treeseq_t *>(R_ExternalPtrAddr(R_altrep_data1(x)));
  if (ts == nullptr) Rf_error("Invalid tree-sequence pointer");
  return ts;
}
inline const double *get_ptr(SEXP x) { return get_ts(x)->tables->nodes.time; }
inline R_xlen_t get_n(SEXP x) {
  return static_cast<R_xlen_t>(tsk_treeseq_get_num_nodes(get_ts(x)));
}

R_xlen_t len(SEXP x) { return get_n(x); }
double elt(SEXP x, R_xlen_t i) { return get_ptr(x)[i]; }
const void *dataptr_or_null(SEXP x) { return get_ptr(x); }
void *dataptr(SEXP x, Rboolean writeable) {
  if (writeable) Rf_error("nodes.time ALTREP is read-only");
  return const_cast<double *>(get_ptr(x));
}
SEXP duplicate(SEXP x, Rboolean) {
  const auto n = get_n(x);
  SEXP out = PROTECT(Rf_allocVector(REALSXP, n));
  std::memcpy(REAL(out), get_ptr(x), static_cast<size_t>(n) * sizeof(double));
  UNPROTECT(1);
  return out;
}
} // namespace

extern "C" void RcppTskit_init_altrep(DllInfo *dll) {
  nodes_time_cls = R_make_altreal_class("rcppts_nodes_time_altrep", "RcppTskit", dll);
  R_set_altrep_Length_method(nodes_time_cls, len);
  R_set_altreal_Elt_method(nodes_time_cls, elt);
  R_set_altvec_Dataptr_or_null_method(nodes_time_cls, dataptr_or_null);
  R_set_altvec_Dataptr_method(nodes_time_cls, dataptr);
  R_set_altrep_Duplicate_method(nodes_time_cls, duplicate);
}

SEXP ts_ptr_nodes_time_altrep(SEXP ts_ptr) {
  if (nodes_time_cls == nullptr) Rf_error("ALTREP class not initialized");
  return R_new_altrep(nodes_time_cls, ts_ptr, R_NilValue);
}

-------------------------------------------------------------------------------

A more complicated one:

// src/altrep_nodes_time.cpp
#include <Rinternals.h>
#include <R_ext/Altrep.h>
#include <R_ext/Rdynload.h>
#include <RcppTskit.hpp>
#include <cstring>

namespace {
R_altrep_class_t nodes_time_altrep_class = nullptr;

struct DblView {
  const double *ptr;
  R_xlen_t n;
};

void view_finalizer(SEXP ext) {
  auto *view = static_cast<DblView *>(R_ExternalPtrAddr(ext));
  delete view;
  R_ClearExternalPtr(ext);
}

R_xlen_t nodes_time_length(SEXP x) {
  auto *view = static_cast<DblView *>(R_ExternalPtrAddr(R_altrep_data2(x)));
  return view->n;
}

double nodes_time_elt(SEXP x, R_xlen_t i) {
  auto *view = static_cast<DblView *>(R_ExternalPtrAddr(R_altrep_data2(x)));
  return view->ptr[i];
}

const void *nodes_time_dataptr_or_null(SEXP x) {
  auto *view = static_cast<DblView *>(R_ExternalPtrAddr(R_altrep_data2(x)));
  return view->ptr; // points to tskit C memory (zero-copy)
}

void *nodes_time_dataptr(SEXP x, Rboolean writeable) {
  if (writeable) {
    Rf_error("nodes.time ALTREP is read-only");
  }
  return const_cast<void *>(nodes_time_dataptr_or_null(x));
}

SEXP nodes_time_duplicate(SEXP x, Rboolean deep) {
  auto *view = static_cast<DblView *>(R_ExternalPtrAddr(R_altrep_data2(x)));
  SEXP out = PROTECT(Rf_allocVector(REALSXP, view->n));
  std::memcpy(REAL(out), view->ptr, static_cast<size_t>(view->n) * sizeof(double));
  UNPROTECT(1);
  return out;
}

void init_nodes_time_altrep(DllInfo *dll) {
  nodes_time_altrep_class =
      R_make_altreal_class("rcppts_nodes_time_altrep", "RcppTskit", dll);
  R_set_altrep_Length_method(nodes_time_altrep_class, nodes_time_length);
  R_set_altreal_Elt_method(nodes_time_altrep_class, nodes_time_elt);
  R_set_altvec_Dataptr_or_null_method(nodes_time_altrep_class, nodes_time_dataptr_or_null);
  R_set_altvec_Dataptr_method(nodes_time_altrep_class, nodes_time_dataptr);
  R_set_altrep_Duplicate_method(nodes_time_altrep_class, nodes_time_duplicate);
}
} // namespace

// call this from package init with DllInfo*
extern "C" void RcppTskit_init_altrep(DllInfo *dll) {
  init_nodes_time_altrep(dll);
}

// [[Rcpp::export]]
SEXP ts_ptr_nodes_time_altrep(SEXP ts_ptr) {
  if (nodes_time_altrep_class == nullptr) {
    Rf_error("ALTREP class not initialized");
  }

  RcppTskit_treeseq_xptr ts(ts_ptr);
  auto *view = new DblView{
      ts->tables->nodes.time,
      static_cast<R_xlen_t>(tsk_treeseq_get_num_nodes(ts))
  };

  SEXP view_ext = PROTECT(R_MakeExternalPtr(view, R_NilValue, R_NilValue));
  R_RegisterCFinalizerEx(view_ext, view_finalizer, TRUE);

  // data1 keeps owner alive; data2 stores pointer/len metadata
  SEXP out = R_new_altrep(nodes_time_altrep_class, ts_ptr, view_ext);
  UNPROTECT(1);
  return out;
}

-------------------------------------------------------------------------------

# in TreeSequence
nodes_time <- function() {
  ts_ptr_nodes_time_altrep(self$pointer)
}

ts <- ts_load(ts_file)
x <- ts$nodes_time() # ALTREP vector, read-only, zero-copy view
x[1:5]

-------------------------------------------------------------------------------

// TODO: This will go into AlphaSimR
// [[Rcpp::export]]
SEXP tc_grow(SEXP tc) {
  RcppTskit_table_collection_xptr tc_xptr(tc);
  int ret;
  ret = 0;
  // TODO: What do we need to do here now? How do we grow a tree sequence?
  //       Look into the simple example in C code online or look into what SLiM
  //       is doing!?
  if (ret != 0) {
    // TODO: What should we do if something goes wrong? We can clearly throw an
    //       error using Rcpp::stop(), but should we also do something with the
    //       ts pointer and object? If we delete, we discard/delete past work,
    //       but if we don't, do we risk of returning a corrupted ts?
    // tsk_table_collection_free(tc_ptr);
    // delete tc_ptr;
    Rcpp::stop(tsk_strerror(ret));
  }
  return tc_xptr;
  // or do we want to return ts?
}

* This PR nicely shows how slendr is dealing with ts objects
  (it saves various ts information as attributes)
  https://github.com/bodkan/slendr/pull/191/changes#diff-f46eb0da2f9267022ecc6e09316598fde6bdcd2f980963906dc041b5096f344f

* TODO Tskit examples of building tree sequence in C
extern/tskit/c/tests/testlib.c has lots of examples of constructing a tree sequence using C
extern/tskit/c/tests/test_minimal_cpp.cpp has some C++ example too
extern/tskit/c/examples/haploid_wright_fisher.c
extern/tskit/c/examples/multichrom_wright_fisher_singlethreaded.c
extern/tskit/c/examples/multichrom_wright_fisher.c

This test nicely shows the required columns:

static void
test_missing_required_columns(void)
{
    int ret;
    size_t j;
    tsk_treeseq_t *ts = caterpillar_tree(5, 3, 3);
    tsk_table_collection_t t;
    const char *required_cols[] = {
        "edges/child",
        "edges/left",
        "edges/parent",
        "edges/right",
        "format/name",
        "format/version",
        "individuals/flags",
        "migrations/dest",
        "migrations/left",
        "migrations/node",
        "migrations/right",
        "migrations/source",
        "migrations/time",
        "mutations/node",
        "mutations/parent",
        "mutations/site",
        "nodes/flags",
        "nodes/individual",
        "nodes/population",
        "nodes/time",
        "sequence_length",
        "sites/position",
        "uuid",
    };
    const char *drop_cols[1];

    for (j = 0; j < sizeof(required_cols) / sizeof(*required_cols); j++) {
        drop_cols[0] = required_cols[j];
        copy_store_drop_columns(ts, 1, drop_cols, _tmp_file_name);
        ret = tsk_table_collection_load(&t, _tmp_file_name, 0);
        CU_ASSERT_EQUAL_FATAL(ret, TSK_ERR_REQUIRED_COL_NOT_FOUND);
        tsk_table_collection_free(&t);
    }

    tsk_treeseq_free(ts);
    free(ts);
}

## NEWS template

```
## [Unreleased] - YYYY-MM-DD

Routinely log changes in the package ...

## [MAJOR.MINOR.PATCH] - YYYY-MM-DD

MAJOR version when you make incompatible API changes
MINOR version when you add functionality in a backward compatible manner
PATCH version when you make backward compatible bug fixes

### Added (new features)

- Describe 1 ...
- Describe 2 ...

### Changed (for changes in existing functionality)
### Deprecated (soon-to-be removed features)
### Removed (now removed features)
### Fixed (bug fixes)
### Security (vulnerabilities)
```

## Prepare for release

```
use_upkeep_issue(year = NULL) # https://usethis.r-lib.org/reference/use_upkeep_issue.html
use_release_issue(version = NULL) # https://usethis.r-lib.org/reference/use_release_issue.html
# just follow tasks in there;)
```

## Dev tools setup / use

```
install.packages(c("usethis", "devtools"))
```

### Code testing coverage with covr

https://covr.r-lib.org

```
install.packages("covr")

# https://usethis.r-lib.org/reference/use_coverage.html
usethis::use_coverage(type = "codecov")

# Build the report & report
cov <- covr::package_coverage(clean = TRUE); covr::report(cov)

# Build the report
cov <- covr::package_coverage(clean = TRUE)

# Interactive HTML report with uncovered lines highlighted
covr::report(cov)

# List lines with zero coverage per file
covr::zero_coverage(cov)

# Show coverage for a specific file
covr::report(cov, file = "R/RcppTskit-package.R")
covr::report(cov, file = "src/RcppTskit_minimal.cpp")

# If you want a quick text view of uncovered lines:
covr::file_coverage("R/RcppTskit-package.R", "tests/testthat")
covr::file_coverage("src/RcppTskit_minimal.cpp", "tests/testthat")
```

To ignore specific lines, use `# nocov`

To ignore multiple lines use `# nocov start/stop`.

In `Rcpp` code use `// # nocov ...`.

### Debugging C/C++

In `src/Makevars.in` uncomment debug flags ...

From terminal run:

```
# Go to package folder
R_HOME="/Library/Frameworks/R.framework/Resources"
R_BIN="$R_HOME/bin/exec/R"
ASAN="/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/17/lib/darwin/libclang_rt.asan_osx_dynamic.dylib"
UBSAN="/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/17/lib/darwin/libclang_rt.ubsan_osx_dynamic.dylib"

env R_HOME="$R_HOME" \
  DYLD_INSERT_LIBRARIES="$ASAN:$UBSAN" \
  ASAN_OPTIONS="abort_on_error=1,detect_leaks=0,verbosity=1" \
  UBSAN_OPTIONS="print_stacktrace=1" \
  "$R_BIN" --vanilla
```

In the R session (not from Rstudio/Positron!):

```
# Load + compile into the current ASan session (no child R load)
devtools::load_all()

# Run tests in the same process
devtools::test()
```

### Air formatter of R code

https://usethis.r-lib.org/reference/use_air.html
```
usethis::use_air()
```

https://posit-dev.github.io/air

Setup editor and `air.toml`.

In comand line, run:

```
air format .
air format --check .
```

### Jarl linter of R code

https://jarl.etiennebacher.com

Setup editor and `jarl.toml`. Can also do `~/.config/jarl`.

```
jarl check .
jarl check --fix .
```

### clang-format of C/C++ code

https://clang.llvm.org/docs/ClangFormat.html

```
# All files (run from the RcppTskit directory)
find src -type f \( -name '*.c' -o -name '*.cpp' -o -name '*.h' -o -name '*.hpp' \) \
  ! -path 'inst/include/tskit/*' \
  ! -path 'src/tskit/*' \
  ! -path 'src/RcppExports.cpp' \
  -exec clang-format -i {} +

# All files (run from the repo root)
find . -type f \( -name '*.c' -o -name '*.cpp' -o -name '*.h' -o -name '*.hpp' \) \
  ! -path './extern/*' \
  ! -path './RcppTskit/inst/include/tskit/*' \
  ! -path './RcppTskit/src/tskit/*' \
  ! -path './RcppTskit/src/RcppExports.cpp' \
  -exec clang-format -i {} +

# Single file
clang-format -i --style=file src/RcppTskit_minimal.cpp

# Only changes
git diff --name-only main | grep -E '\.(c|cpp|h|hpp)$' | xargs clang-format -i
```

or

```
pre-commit run clang-format src/RcppTskit.cpp
pre-commit run clang-format --all-files
```

### clang-tidy linter of C/C++ code

https://clang.llvm.org/extra/clang-tidy/

```
echo $(brew --prefix llvm)/bin/clang-tidy
# /opt/homebrew/opt/llvm/bin/clang-tidy
export CLANG_TIDY="$(brew --prefix llvm)/bin/clang-tidy"
./tools/clang-tidy.py src/RcppTskit.cpp
./RcppTskit/tools/clang-tidy.py RcppTskit/src/test_tsk_abort_stderr.cpp -- -system-headers '-header-filter=.*'   -extra-arg=-Wno-unknown-warning-option
./tools/clang-tidy.py src/test_tsk_abort_stderr.cpp -- -system-headers '-header-filter=.*'   -extra-arg=-Wno-unknown-warning-option
```

or

```
pre-commit run clang-tidy src/RcppTskit.cpp
pre-commit run clang-tidy --all-files
```

### GitHub actions

```
install.packages("usethis")

# R CMD check
usethis::use_github_action("check-standard")

# Code testing coverage with covr
usethis::use_github_action("test-coverage")

# Air formatting --> moved to pre-commit
usethis::use_github_action(url = "https://github.com/posit-dev/setup-air/blob/main/examples/format-suggest.yaml")
usethis::use_github_action(url = "https://github.com/posit-dev/setup-air/blob/main/examples/format-check.yaml")
```
